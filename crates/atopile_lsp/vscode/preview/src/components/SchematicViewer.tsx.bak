import React, { useCallback, useEffect, useRef, useState } from "react";
import ELK from "elkjs/lib/elk.bundled.js";
import {
  Component,
  Connection,
  ComponentType,
  Port,
  SchematicLevel,
  HierarchicalSchematic,
} from "../types";

// ElkJS specific interfaces for layout calculation
interface ElkNode {
  id: string;
  width: number;
  height: number;
  x?: number;
  y?: number;
  children?: ElkNode[];
  ports?: ElkPort[];
  labels?: ElkLabel[];
  properties?: Record<string, string>;
}

interface ElkPort {
  id: string;
  width: number;
  height: number;
  x?: number;
  y?: number;
  properties?: Record<string, string>;
}

interface ElkLabel {
  text: string;
  x?: number;
  y?: number;
  width?: number;
  height?: number;
}

interface ElkEdge {
  id: string;
  sources: string[];
  targets: string[];
  labels?: ElkLabel[];
  sections?: {
    startPoint: { x: number; y: number };
    endPoint: { x: number; y: number };
    bendPoints?: { x: number; y: number }[];
  }[];
}

interface ElkGraph {
  id: string;
  children: ElkNode[];
  edges: ElkEdge[];
}

interface SchematicViewerProps {
  schematic?: HierarchicalSchematic;
  showDebug?: boolean;
  onError?: (message: string) => void;
  onComponentSelect?: (componentId: string | null) => void;
  onNavigateToChild?: (childId: string) => void;
  onNavigateToParent?: () => void;
}

const SchematicViewer: React.FC<SchematicViewerProps> = ({
  schematic,
  showDebug = false,
  onError = () => {},
  onComponentSelect = () => {},
  onNavigateToChild = () => {},
  onNavigateToParent = () => {},
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [layout, setLayout] = useState<ElkGraph | null>(null);
  const [layoutError, setLayoutError] = useState<string | null>(null);
  const [debugInfo, setDebugInfo] = useState<any | null>(null);

  // Current schematic level and selection state
  const [currentLevel, setCurrentLevel] = useState<SchematicLevel | null>(null);
  const [selectedComponent, setSelectedComponent] = useState<string | null>(
    null
  );

  // Update the current level when the schematic changes
  useEffect(() => {
    if (schematic) {
      const level = schematic.levels[schematic.currentLevelId];
      setCurrentLevel(level);
    }
  }, [schematic]);

  // Convert our schematic data to ElkJS format
  const createElkGraph = useCallback(() => {
    if (!currentLevel) return null;

    // Convert components to ElkJS nodes
    const elkNodes = currentLevel.components.map((component) => {
      // Calculate dimensions based on component content and fixed size requirements
      let width =
        component.width || getDefaultComponentWidth(component.type, component);
      let height =
        component.height ||
        getDefaultComponentHeight(component.type, component);

      // Ensure minimum size based on component name length
      const nameWidth = component.name.length * 7 + 30; // Add padding for the name
      width = Math.max(width, nameWidth);

      // Make sure we have enough space for port labels
      const portCountAdjustment = component.ports.length * 5;
      width = Math.max(width, 60 + portCountAdjustment);
      height = Math.max(height, 40 + portCountAdjustment);

      // Prepare port arrays for each side
      const westPorts = component.ports.filter(
        (p) => getPortSide(p) === "WEST"
      );
      const eastPorts = component.ports.filter(
        (p) => getPortSide(p) === "EAST"
      );
      const northPorts = component.ports.filter(
        (p) => getPortSide(p) === "NORTH"
      );
      const southPorts = component.ports.filter(
        (p) => getPortSide(p) === "SOUTH"
      );

      // Calculate indexes for proper port positioning
      westPorts.forEach((p, idx) => ((p as any).indexOnSide = idx));
      eastPorts.forEach((p, idx) => ((p as any).indexOnSide = idx));
      northPorts.forEach((p, idx) => ((p as any).indexOnSide = idx));
      southPorts.forEach((p, idx) => ((p as any).indexOnSide = idx));

      // Get port counts
      const portCounts = {
        WEST: westPorts.length,
        EAST: eastPorts.length,
        NORTH: northPorts.length,
        SOUTH: southPorts.length,
      };

      // Convert ports to ElkJS format with explicit positional indexing
      const elkPorts = component.ports.map((port) => {
        const side = getPortSide(port);
        const portIndex = (port as any).indexOnSide || 0;
        const totalPortsOnSide =
          portCounts[side as keyof typeof portCounts] || 1;

        // Calculate relative position based on index and total ports
        let x = 0;
        let y = 0;

        if (side === "WEST" || side === "EAST") {
          // For left/right ports, distribute vertically
          const isLeftSide = side === "WEST";
          x = isLeftSide ? 0 : width; // Left edge or right edge
          // Distribute ports evenly along the height
          if (totalPortsOnSide === 1) {
            y = height / 2; // Center port vertically if single port
          } else {
            const spacing = height / (totalPortsOnSide + 1);
            y = spacing * (portIndex + 1); // Distribute with equal spacing
          }
        } else {
          // For top/bottom ports, distribute horizontally
          const isTopSide = side === "NORTH";
          y = isTopSide ? 0 : height; // Top edge or bottom edge
          // Distribute ports evenly along the width
          if (totalPortsOnSide === 1) {
            x = width / 2; // Center port horizontally if single port
          } else {
            const spacing = width / (totalPortsOnSide + 1);
            x = spacing * (portIndex + 1); // Distribute with equal spacing
          }
        }

        return {
          id: port.id,
          width: 10, // Increased port width for better visibility
          height: 10, // Increased port height
          x: x, // Set explicit port position
          y: y, // Set explicit port position
          // Port properties for layout
          properties: {
            "port.side": side,
            "port.index": portIndex.toString(),
            "port.borderOffset": "0",
            "port.anchor": "CENTER",
          },
        };
      });

      // Create node labels
      const labels = [
        {
          text: component.name,
          width: component.name.length * 6,
          height: 14,
        },
      ];

      // Return the ElkJS node
      return {
        id: component.id,
        width,
        height,
        ports: elkPorts,
        labels,
        // Set additional properties for different component types
        properties: {
          nodeType: component.type,
          expandable: component.hasChildren ? "true" : "false",
        },
      };
    });

    // Convert connections to ElkJS edges
    // const elkEdges = currentLevel.connections.map((connection) => ({
    //   id: connection.id,
    //   sources: [connection.sourcePortId],
    //   targets: [connection.targetPortId],
    //   // Include routing points if available
    //   ...(connection.routingPoints &&
    //     connection.routingPoints.length > 0 && {
    //       sections: [
    //         {
    //           startPoint: { x: 0, y: 0 }, // Will be set by ElkJS
    //           endPoint: { x: 0, y: 0 }, // Will be set by ElkJS
    //           bendPoints: connection.routingPoints,
    //         },
    //       ],
    //     }),
    // }));

    // Return the ElkJS graph structure
    return {
      id: currentLevel.id,
      children: elkNodes,
      edges: [],
    };
  }, [currentLevel]);

  // Perform layout calculation using ElkJS
  useEffect(() => {
    const runLayout = async () => {
      if (!currentLevel) return;

      const elk = new ELK();
      const graph = createElkGraph();

      if (!graph) return;

      const layoutOptions = {
        // Use a layered algorithm which is good for circuit diagrams
        "elk.algorithm": "layered",
        // Right-to-left layout for electrical schematics
        "elk.direction": "RIGHT",
        // Spacing between nodes
        "elk.spacing.nodeNode": "70", // Increased spacing
        // Spacing between layers
        "elk.layered.spacing.nodeNodeBetweenLayers": "100", // Increased for more space between layers
        // Route edges orthogonally (right angles)
        "elk.edges.routing": "ORTHOGONAL",
        // Default node padding - important for port placement
        "elk.padding": "[top=30, left=30, bottom=30, right=30]",
        // Ignore ElkJS port placement - we're manually calculating port positions
        "elk.portConstraints": "FREE",
        // Use fixed node sizes rather than auto-sizing (which is causing issues)
        "elk.nodeSize.constraints": "NODE_LABELS NODE_SIZE",
        "elk.nodeSize.options": "NODE_SIZE_EXPLICIT",
        // Node label placement
        "elk.nodeLabels.placement": "INSIDE, H_CENTER, V_CENTER",
        // Edge routing
        "elk.edges.sourcePoint": "FREE",
        "elk.edges.targetPoint": "FREE",
        // Separate edges more clearly
        "elk.spacing.edgeEdge": "25",
        // Separate edges and nodes more clearly
        "elk.spacing.edgeNode": "30",
        // Aspect ratio settings - wider to accommodate ports better
        "elk.aspectRatio": "1.6",
      };

      try {
        // Use a type assertion to work around ElkJS typings
        const layoutResult = await (elk as any).layout(graph as any, {
          layoutOptions,
        });
        // Fix the type by explicitly casting the result
        setLayout(layoutResult as ElkGraph);

        // Store debug information
        if (showDebug) {
          setDebugInfo({
            graph,
            layoutResult,
            layoutOptions,
          });
        }

        // Clear any previous errors
        setLayoutError(null);
      } catch (error) {
        const errorMessage = `Layout calculation failed: ${
          error instanceof Error ? error.message : String(error)
        }`;
        console.error(errorMessage, error);
        setLayoutError(errorMessage);
        onError(errorMessage);
      }
    };

    runLayout();
  }, [currentLevel, createElkGraph, showDebug, onError]);

  // Handle canvas click
  const handleCanvasClick = useCallback(
    (event: React.MouseEvent<HTMLCanvasElement>) => {
      if (!canvasRef.current || !layout || !currentLevel) return;

      // Get canvas position and calculate relative click position with scale adjustment
      const rect = canvasRef.current.getBoundingClientRect();

      // Use the stored scale attribute if available, otherwise calculate it
      const storedScale = canvasRef.current.getAttribute("data-scale");
      const scaleFactor = storedScale ? parseFloat(storedScale) : 1;

      // Apply the inverse scale to get the actual canvas coordinates
      const canvasX = (event.clientX - rect.left) / scaleFactor;
      const canvasY = (event.clientY - rect.top) / scaleFactor;

      // First check if we clicked on a port - more precise interaction
      let clickedPortId: string | null = null;
      let clickedPortParentId: string | null = null;

      // Search for clicked ports
      for (const node of layout.children) {
        if (node.x === undefined || node.y === undefined || !node.ports)
          continue;

        for (const port of node.ports) {
          if (port.x === undefined || port.y === undefined) continue;

          // Calculate port center and check if click is within port circle
          const portCenterX = port.x + port.width / 2;
          const portCenterY = port.y + port.height / 2;
          const distance = Math.sqrt(
            Math.pow(canvasX - portCenterX, 2) +
              Math.pow(canvasY - portCenterY, 2)
          );

          // Larger hit area for port click detection (making it easier to click)
          const portRadius = Math.max(port.width, 10); // Ensure a minimum clickable area
          if (distance <= portRadius) {
            clickedPortId = port.id;
            clickedPortParentId = node.id;
            break;
          }
        }

        if (clickedPortId) break;
      }

      // If we clicked a port, select its parent component
      if (clickedPortId && clickedPortParentId) {
        setSelectedComponent(clickedPortParentId);
        onComponentSelect(clickedPortParentId);
        return;
      }

      // Otherwise check if we clicked on a component
      let clickedComponentId: string | null = null;

      for (const node of layout.children) {
        if (
          node.x !== undefined &&
          node.y !== undefined &&
          canvasX >= node.x &&
          canvasX <= node.x + node.width &&
          canvasY >= node.y &&
          canvasY <= node.y + node.height
        ) {
          clickedComponentId = node.id;
          break;
        }
      }

      // Update selected component
      if (clickedComponentId) {
        const clickedComponent = currentLevel.components.find(
          (c) => c.id === clickedComponentId
        );
        setSelectedComponent(clickedComponentId);
        onComponentSelect(clickedComponentId);

        // If clicked with double-click and component has children, navigate to it
        if (event.detail === 2 && clickedComponent?.hasChildren) {
          onNavigateToChild(clickedComponentId);
        }
      } else {
        setSelectedComponent(null);
        onComponentSelect(null);
      }

      // Re-render canvas (will happen due to state change)
    },
    [layout, currentLevel, onComponentSelect, onNavigateToChild]
  );

  // Handle navigation to parent level
  const handleNavigateUp = useCallback(() => {
    if (currentLevel?.parent) {
      onNavigateToParent();
    }
  }, [currentLevel, onNavigateToParent]);

  // Render the canvas with components and connections
  const renderCanvas = useCallback(() => {
    if (!layout || !canvasRef.current || !currentLevel) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Calculate canvas size and scaling
    let maxX = 0;
    let maxY = 0;

    // Check components for max dimensions
    layout.children.forEach((node) => {
      if (node.x !== undefined && node.y !== undefined) {
        maxX = Math.max(maxX, node.x + node.width);
        maxY = Math.max(maxY, node.y + node.height);
      }
    });

    // Add padding for labels and consistent aspect ratio
    const PADDING = 80; // Increased padding for port labels
    maxX += PADDING;
    maxY += PADDING;

    // Set a minimum size to ensure consistency
    maxX = Math.max(maxX, 400);
    maxY = Math.max(maxY, 300);

    // Maintain aspect ratio if needed
    const containerWidth = canvas.parentElement?.clientWidth || maxX;
    const containerHeight = canvas.parentElement?.clientHeight || maxY;

    // Calculate the scaling factor for the container
    const scaleX = containerWidth / maxX;
    const scaleY = containerHeight / maxY;
    const scale = Math.min(scaleX, scaleY, 1); // Don't scale up beyond 1

    // Set canvas dimensions with consistent aspect ratio
    canvas.width = maxX;
    canvas.height = maxY;

    // Set the canvas display size in CSS (maintain aspect ratio)
    canvas.style.width = `${maxX * scale}px`;
    canvas.style.height = `${maxY * scale}px`;

    // Store the scale factor as a data attribute for hit detection
    canvas.setAttribute("data-scale", scale.toString());

    // Set background grid for schematic - lighter for cleaner look
    const gridSize = 20;
    ctx.strokeStyle = "rgba(200, 200, 200, 0.15)";
    ctx.lineWidth = 0.5;

    // Draw vertical grid lines
    for (let x = 0; x < canvas.width; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }

    // Draw horizontal grid lines
    for (let y = 0; y < canvas.height; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.stroke();
    }

    // Now draw the edges (connections)
    ctx.strokeStyle = "#444";
    ctx.lineWidth = 1.5;

    // Draw edges (connections) with correct coordinates
    layout.edges.forEach((edge) => {
      const sourceId = edge.sources[0];
      const targetId = edge.targets[0];

      // We need to find the parent node for each port
      let sourcePort = null,
        targetPort = null;
      let sourceNode = null,
        targetNode = null;

      // Search through all nodes and their ports
      for (const node of layout.children) {
        if (!node.ports) continue;

        // Find the matching ports
        for (const port of node.ports) {
          if (port.id === sourceId) {
            sourcePort = port;
            sourceNode = node;
          }

          if (port.id === targetId) {
            targetPort = port;
            targetNode = node;
          }

          // Break early if we found both
          if (sourcePort && targetPort) break;
        }

        // Break early if we found both
        if (sourcePort && targetPort) break;
      }

      // Only draw if we found both source and target
      if (sourcePort && targetPort && sourceNode && targetNode) {
        try {
          // Calculate absolute coordinates for the ports
          // Port position = Node position + port's relative position
          const sourceX =
            (sourceNode.x || 0) +
            (sourcePort.x || 0) +
            (sourcePort.width || 0) / 2;
          const sourceY =
            (sourceNode.y || 0) +
            (sourcePort.y || 0) +
            (sourcePort.height || 0) / 2;

          const targetX =
            (targetNode.x || 0) +
            (targetPort.x || 0) +
            (targetPort.width || 0) / 2;
          const targetY =
            (targetNode.y || 0) +
            (targetPort.y || 0) +
            (targetPort.height || 0) / 2;

          // Get port sides for routing
          const sourceSide = sourcePort.properties?.["port.side"] || "WEST";
          const targetSide = targetPort.properties?.["port.side"] || "EAST";

          // Initialize draw path
          ctx.beginPath();
          ctx.moveTo(sourceX, sourceY);

          // Determine routing based on port sides
          // This provides better routing for different side combinations
          if (sourceSide === "EAST" && targetSide === "WEST") {
            // Direct horizontal connection
            const midX = (sourceX + targetX) / 2;
            ctx.lineTo(midX, sourceY);
            ctx.lineTo(midX, targetY);
            ctx.lineTo(targetX, targetY);
          } else if (sourceSide === "WEST" && targetSide === "EAST") {
            // Reverse flow - need to route around
            const offset = 30; // Distance for the vertical segment
            ctx.lineTo(sourceX - offset, sourceY);
            ctx.lineTo(
              sourceX - offset,
              sourceY < targetY ? sourceY - offset : sourceY + offset
            );
            ctx.lineTo(
              targetX + offset,
              sourceY < targetY ? sourceY - offset : sourceY + offset
            );
            ctx.lineTo(targetX + offset, targetY);
            ctx.lineTo(targetX, targetY);
          } else if (sourceSide === "NORTH" && targetSide === "SOUTH") {
            // Direct vertical connection
            const midY = (sourceY + targetY) / 2;
            ctx.lineTo(sourceX, midY);
            ctx.lineTo(targetX, midY);
            ctx.lineTo(targetX, targetY);
          } else if (sourceSide === "SOUTH" && targetSide === "NORTH") {
            // Reverse vertical flow - need to route around
            const offset = 30; // Distance for the horizontal segment
            ctx.lineTo(sourceX, sourceY + offset);
            ctx.lineTo(
              sourceX < targetX ? sourceX - offset : sourceX + offset,
              sourceY + offset
            );
            ctx.lineTo(
              sourceX < targetX ? sourceX - offset : sourceX + offset,
              targetY - offset
            );
            ctx.lineTo(targetX, targetY - offset);
            ctx.lineTo(targetX, targetY);
          } else {
            // Mixed sides - use simple orthogonal routing
            if (sourceSide === "EAST" || sourceSide === "WEST") {
              // Source is on horizontal side
              const xDist = Math.abs(targetX - sourceX);
              const yDist = Math.abs(targetY - sourceY);

              if (xDist > yDist) {
                // Route horizontally first
                const midX = (sourceX + targetX) / 2;
                ctx.lineTo(midX, sourceY);
                ctx.lineTo(midX, targetY);
              } else {
                // Route vertically first
                const midY = (sourceY + targetY) / 2;
                ctx.lineTo(sourceX, midY);
                ctx.lineTo(targetX, midY);
              }
            } else {
              // Source is on vertical side
              const xDist = Math.abs(targetX - sourceX);
              const yDist = Math.abs(targetY - sourceY);

              if (yDist > xDist) {
                // Route vertically first
                const midY = (sourceY + targetY) / 2;
                ctx.lineTo(sourceX, midY);
                ctx.lineTo(targetX, midY);
              } else {
                // Route horizontally first
                const midX = (sourceX + targetX) / 2;
                ctx.lineTo(midX, sourceY);
                ctx.lineTo(midX, targetY);
              }
            }

            // Final segment to target
            ctx.lineTo(targetX, targetY);
          }

          // Draw the path
          ctx.stroke();
        } catch (error) {
          // Fallback to a simple direct line if there's an error in routing
          ctx.beginPath();
          ctx.moveTo(
            (sourceNode.x || 0) +
              (sourcePort.x || 0) +
              (sourcePort.width || 0) / 2,
            (sourceNode.y || 0) +
              (sourcePort.y || 0) +
              (sourcePort.height || 0) / 2
          );
          ctx.lineTo(
            (targetNode.x || 0) +
              (targetPort.x || 0) +
              (targetPort.width || 0) / 2,
            (targetNode.y || 0) +
              (targetPort.y || 0) +
              (targetPort.height || 0) / 2
          );
          ctx.stroke();
        }
      }
    });

    // Draw the components
    layout.children.forEach((node) => {
      if (node.x === undefined || node.y === undefined) return;

      const component = currentLevel.components.find((c) => c.id === node.id);
      if (!component) return;

      // Component is being rendered here

      // Set base styles
      ctx.fillStyle = "#fff";
      ctx.strokeStyle = "#333";
      ctx.lineWidth = 2;

      // Highlight selected component
      const isSelected = selectedComponent === component.id;
      if (isSelected) {
        // Draw selection highlight
        ctx.save();
        ctx.strokeStyle = "#1e90ff"; // Dodger blue
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.rect(node.x - 3, node.y - 3, node.width + 6, node.height + 6);
        ctx.stroke();
        ctx.restore();
      }

      // Calculate common values used by multiple component types
      const centerY = node.y + node.height / 2;
      const centerX = node.x + node.width / 2;

      // Draw different components based on type
      renderComponent(ctx, component, node, isSelected);

      // Draw component label
      ctx.fillStyle = isSelected ? "#0066cc" : "#000";
      ctx.font = isSelected ? "bold 10px Arial" : "10px Arial";
      ctx.textAlign = "center";
      ctx.fillText(
        component.name,
        node.x + node.width / 2,
        node.y + node.height + 15
      );

      // Draw expandable indicator for modules with children
      if (component.hasChildren) {
        ctx.fillStyle = isSelected ? "#0066cc" : "#666";
        ctx.beginPath();
        ctx.moveTo(node.x + node.width - 10, node.y + node.height - 10);
        ctx.lineTo(node.x + node.width - 5, node.y + node.height - 10);
        ctx.lineTo(node.x + node.width - 7.5, node.y + node.height - 5);
        ctx.closePath();
        ctx.fill();
      }

      // Draw ports and port labels
      if (node.ports) {
        node.ports.forEach((port) => {
          if (port.x === undefined || port.y === undefined) return;

          // Find the corresponding port in the component
          const componentPort = component.ports.find((p) => p.id === port.id);
          if (!componentPort) return;

          // Calculate port positions relative to the node
          if (
            port.x === undefined ||
            port.y === undefined ||
            isNaN(port.x) ||
            isNaN(port.y)
          ) {
            return; // Skip invalid ports quietly
          }

          // Get port position information
          const portSide = getPortSide(componentPort);

          // Get absolute coordinates by adding node position
          const portX = node.x !== undefined ? node.x + port.x : port.x;
          const portY = node.y !== undefined ? node.y + port.y : port.y;
          const portCenterX = portX + port.width / 2;
          const portCenterY = portY + port.height / 2;

          // Draw different port styles based on component type and port side
          const isActive = isSelected || showDebug;

          // Determine port style - simpler, cleaner look
          const portRadius = Math.max(Math.min(port.width, port.height) / 2, 3);
          let portStrokeColor = isSelected ? "#1e90ff" : "#333";
          let portFillColor = isSelected
            ? "rgba(30, 144, 255, 0.8)"
            : "rgba(0, 0, 0, 0.5)";
          let portStrokeWidth = 1;

          // Draw the port based on its side
          switch (portSide) {
            case "EAST":
            case "WEST": {
              // Draw port as a small circle
              ctx.fillStyle = portFillColor;
              ctx.beginPath();
              ctx.arc(portCenterX, portCenterY, portRadius, 0, Math.PI * 2);
              ctx.fill();

              ctx.strokeStyle = portStrokeColor;
              ctx.lineWidth = portStrokeWidth;
              ctx.beginPath();
              ctx.arc(portCenterX, portCenterY, portRadius, 0, Math.PI * 2);
              ctx.stroke();
              break;
            }
            case "NORTH":
            case "SOUTH": {
              // Draw port as a small square for top/bottom sides
              ctx.fillStyle = portFillColor;
              ctx.fillRect(
                portCenterX - portRadius,
                portCenterY - portRadius,
                portRadius * 2,
                portRadius * 2
              );

              ctx.strokeStyle = portStrokeColor;
              ctx.lineWidth = portStrokeWidth;
              ctx.strokeRect(
                portCenterX - portRadius,
                portCenterY - portRadius,
                portRadius * 2,
                portRadius * 2
              );
              break;
            }
            default: {
              // Default circle for any other ports
              ctx.fillStyle = portFillColor;
              ctx.beginPath();
              ctx.arc(portCenterX, portCenterY, portRadius, 0, Math.PI * 2);
              ctx.fill();

              ctx.strokeStyle = portStrokeColor;
              ctx.lineWidth = portStrokeWidth;
              ctx.beginPath();
              ctx.arc(portCenterX, portCenterY, portRadius, 0, Math.PI * 2);
              ctx.stroke();
            }
          }

          // Draw port label if component is selected or in debug mode
          if (isActive) {
            // Calculate label position based on port side
            let labelX = portCenterX;
            let labelY = portCenterY;
            let textAlign: CanvasTextAlign = "center";

            // Position label based on port side
            const padding = 8; // Adjust this for more/less space between port and label

            switch (portSide) {
              case "WEST":
                labelX = portCenterX - padding;
                labelY = portCenterY;
                textAlign = "right";
                break;
              case "EAST":
                labelX = portCenterX + padding;
                labelY = portCenterY;
                textAlign = "left";
                break;
              case "NORTH":
                labelX = portCenterX;
                labelY = portCenterY - padding;
                textAlign = "center";
                break;
              case "SOUTH":
                labelX = portCenterX;
                labelY = portCenterY + padding + 8; // Add extra space for text height
                textAlign = "center";
                break;
            }

            // Set text properties
            ctx.fillStyle = "#333";
            ctx.font = "bold 9px Arial";
            ctx.textAlign = textAlign;

            // Measure text for background
            const label = componentPort.name;
            const textMetrics = ctx.measureText(label);
            const textWidth = textMetrics.width;
            const textHeight = 9; // Font size
            const bgPadding = 2;

            // Calculate background rectangle coordinates
            let bgX = 0;
            let bgY = labelY - textHeight - bgPadding;
            let bgWidth = textWidth + bgPadding * 2;
            let bgHeight = textHeight + bgPadding * 2;

            if (textAlign === "center") {
              bgX = labelX - textWidth / 2 - bgPadding;
            } else if (textAlign === "left") {
              bgX = labelX - bgPadding;
            } else {
              // right
              bgX = labelX - textWidth - bgPadding;
            }

            // Draw text background with subtle gradient for a cleaner look
            const gradient = ctx.createLinearGradient(
              bgX,
              bgY,
              bgX,
              bgY + bgHeight
            );
            gradient.addColorStop(0, "rgba(255, 255, 255, 0.95)");
            gradient.addColorStop(1, "rgba(245, 245, 245, 0.95)");
            ctx.fillStyle = gradient;

            // Rounded rectangle for better aesthetics
            const radius = 2;
            ctx.beginPath();
            ctx.moveTo(bgX + radius, bgY);
            ctx.lineTo(bgX + bgWidth - radius, bgY);
            ctx.quadraticCurveTo(
              bgX + bgWidth,
              bgY,
              bgX + bgWidth,
              bgY + radius
            );
            ctx.lineTo(bgX + bgWidth, bgY + bgHeight - radius);
            ctx.quadraticCurveTo(
              bgX + bgWidth,
              bgY + bgHeight,
              bgX + bgWidth - radius,
              bgY + bgHeight
            );
            ctx.lineTo(bgX + radius, bgY + bgHeight);
            ctx.quadraticCurveTo(
              bgX,
              bgY + bgHeight,
              bgX,
              bgY + bgHeight - radius
            );
            ctx.lineTo(bgX, bgY + radius);
            ctx.quadraticCurveTo(bgX, bgY, bgX + radius, bgY);
            ctx.closePath();
            ctx.fill();

            // Add subtle border
            ctx.strokeStyle = "rgba(210, 210, 210, 0.5)";
            ctx.lineWidth = 0.5;
            ctx.stroke();

            // Draw text
            ctx.fillStyle = "#333";
            ctx.fillText(label, labelX, labelY);
          }
        });
      }
    });

    // Canvas has been rendered
  }, [layout, currentLevel, selectedComponent, showDebug]);

  // Render a component based on its type
  const renderComponent = (
    ctx: CanvasRenderingContext2D,
    component: Component,
    node: ElkNode,
    isSelected: boolean
  ) => {
    if (node.x === undefined || node.y === undefined) return;

    // Common positioning values for component rendering
    const centerY = node.y + node.height / 2;
    const centerX = node.x + node.width / 2;

    // Default styles
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = isSelected ? "#1e90ff" : "#333";

    // Base fill color for all components
    const baseFill = isSelected
      ? "rgba(230, 240, 255, 0.9)"
      : "rgba(255, 255, 255, 0.9)";

    switch (component.type) {
      case ComponentType.RESISTOR:
        // Draw resistor as a simple rectangle with symbol
        ctx.fillStyle = baseFill;
        ctx.fillRect(node.x, node.y, node.width, node.height);
        ctx.strokeRect(node.x, node.y, node.width, node.height);

        // Standard resistor symbol (simple zigzag line)
        ctx.beginPath();
        const zigzagWidth = node.width * 0.6;
        const startX = node.x + (node.width - zigzagWidth) / 2;
        const zigHeight = Math.min(6, node.height * 0.25);
        const segments = 6;
        const segWidth = zigzagWidth / segments;

        ctx.moveTo(startX, centerY);
        for (let i = 0; i < segments; i++) {
          const direction = i % 2 === 0 ? 1 : -1;
          ctx.lineTo(
            startX + (i + 0.5) * segWidth,
            centerY + direction * zigHeight
          );
          ctx.lineTo(startX + (i + 1) * segWidth, centerY);
        }
        ctx.stroke();
        break;

      case ComponentType.CAPACITOR:
        // Draw capacitor as a rectangle
        ctx.fillStyle = baseFill;
        ctx.fillRect(node.x, node.y, node.width, node.height);
        ctx.strokeRect(node.x, node.y, node.width, node.height);

        // Draw standard capacitor symbol (two parallel lines)
        const plateGap = Math.min(8, node.width * 0.15);
        const leftPlate = centerX - plateGap / 2;
        const rightPlate = centerX + plateGap / 2;

        ctx.lineWidth = 1.5;
        // Left plate
        ctx.beginPath();
        ctx.moveTo(leftPlate, node.y + node.height * 0.25);
        ctx.lineTo(leftPlate, node.y + node.height * 0.75);
        ctx.stroke();

        // Right plate
        ctx.beginPath();
        ctx.moveTo(rightPlate, node.y + node.height * 0.25);
        ctx.lineTo(rightPlate, node.y + node.height * 0.75);
        ctx.stroke();
        break;

      case ComponentType.DIODE:
        // Draw diode as a rectangle
        ctx.fillStyle = baseFill;
        ctx.fillRect(node.x, node.y, node.width, node.height);
        ctx.strokeRect(node.x, node.y, node.width, node.height);

        // Draw standard diode symbol (triangle with line)
        const triangleSize = Math.min(node.width * 0.3, node.height * 0.5);

        // Triangle
        ctx.beginPath();
        ctx.moveTo(centerX - triangleSize, centerY - triangleSize);
        ctx.lineTo(centerX + triangleSize, centerY);
        ctx.lineTo(centerX - triangleSize, centerY + triangleSize);
        ctx.closePath();
        ctx.fillStyle = "#333";
        ctx.fill();

        // Line
        ctx.beginPath();
        ctx.moveTo(centerX + triangleSize, centerY - triangleSize);
        ctx.lineTo(centerX + triangleSize, centerY + triangleSize);
        ctx.stroke();
        break;

      case ComponentType.JUNCTION:
        // Draw junction as a small filled circle
        ctx.fillStyle = isSelected ? "#1e90ff" : "#333";
        ctx.beginPath();
        ctx.arc(centerX, centerY, 4, 0, Math.PI * 2);
        ctx.fill();
        break;

      case ComponentType.IC:
        // Draw IC as a clean rectangle
        ctx.fillStyle = baseFill;
        ctx.fillRect(node.x, node.y, node.width, node.height);
        ctx.strokeRect(node.x, node.y, node.width, node.height);

        // Add a small identifier mark at the top
        const notchWidth = Math.min(10, node.width * 0.2);
        const notchHeight = Math.min(5, node.height * 0.1);
        ctx.fillStyle = "#333";
        ctx.fillRect(centerX - notchWidth / 2, node.y, notchWidth, notchHeight);
        break;

      case ComponentType.MODULE:
        // Draw module as a clean white rectangle as requested
        ctx.fillStyle = "rgba(255, 255, 255, 0.95)";

        // Draw rectangle with thin border
        ctx.fillRect(node.x, node.y, node.width, node.height);
        ctx.strokeRect(node.x, node.y, node.width, node.height);
        break;

      case ComponentType.PORT:
        // Draw port as a small connector shape
        ctx.fillStyle = baseFill;

        // Draw a clean rectangle
        ctx.fillRect(node.x, node.y, node.width, node.height);
        ctx.strokeRect(node.x, node.y, node.width, node.height);
        break;

      case ComponentType.BUTTON:
        // Draw button as a rectangle
        ctx.fillStyle = baseFill;
        ctx.fillRect(node.x, node.y, node.width, node.height);
        ctx.strokeRect(node.x, node.y, node.width, node.height);

        // Draw small button indicator
        const btnSize = Math.min(node.width, node.height) * 0.3;
        ctx.beginPath();
        ctx.arc(centerX, centerY, btnSize, 0, Math.PI * 2);
        ctx.fillStyle = isSelected ? "#b0c4de" : "#d0d0d0";
        ctx.fill();
        ctx.stroke();
        break;

      default:
        // Generic component - just a rectangle
        ctx.fillStyle = baseFill;
        ctx.fillRect(node.x, node.y, node.width, node.height);
        ctx.strokeRect(node.x, node.y, node.width, node.height);
    }

    // Draw component name more prominently
    ctx.fillStyle = isSelected ? "#0066cc" : "#333";
    ctx.font = isSelected ? "bold 11px Arial" : "11px Arial";
    ctx.textAlign = "center";
    ctx.fillText(component.name, centerX, centerY);

    // Draw component value if available (smaller, below the name)
    if (component.value) {
      ctx.fillStyle = "#666";
      ctx.font = "9px Arial";
      ctx.fillText(component.value, centerX, centerY + 14);
    }
  };

  // Helper function to get the appropriate port side for ELK layout
  const getPortSide = (port: Port): string => {
    switch (port.position) {
      case "left":
        return "WEST";
      case "right":
        return "EAST";
      case "top":
        return "NORTH";
      case "bottom":
        return "SOUTH";
      default: {
        // Infer from port name
        // const name = port.name.toLowerCase();
        // if (name.includes('in') || name.includes('input')) {
        //   return "WEST";
        // } else if (name.includes('out') || name.includes('output')) {
        //   return "EAST";
        // } else if (name.includes('vcc') || name.includes('power') || name.includes('top')) {
        //   return "NORTH";
        // } else if (name.includes('gnd') || name.includes('ground') || name.includes('bottom')) {
        //   return "SOUTH";
        // }
        // Default
        return "WEST";
      }
    }
  };

  // Helper function to get the position for drawing port labels
  const getPortLabelPosition = (
    portSide: string,
    x: number,
    y: number,
    width: number,
    height: number
  ): { x: number; y: number; align: CanvasTextAlign } => {
    switch (portSide) {
      case "WEST":
        return { x: x - 8, y: y + height / 2 + 3, align: "right" };
      case "EAST":
        return { x: x + width + 8, y: y + height / 2 + 3, align: "left" };
      case "NORTH":
        return { x: x + width / 2, y: y - 8, align: "center" };
      case "SOUTH":
        return { x: x + width / 2, y: y + height + 12, align: "center" };
      default:
        return { x: x + width + 8, y: y + height / 2, align: "left" };
    }
  };

  // Helper function to get default width for component types
  // With auto-sizing, these act as minimum dimensions rather than fixed dimensions
  const getDefaultComponentWidth = (
    type: ComponentType,
    component: Component
  ): number => {
    // Calculate a base width based on port count for sides with ports
    let portBasedWidth = 0;
    const leftPorts = component.ports.filter(
      (p) => getPortSide(p) === "WEST"
    ).length;
    const rightPorts = component.ports.filter(
      (p) => getPortSide(p) === "EAST"
    ).length;

    // Allocate width based on port count (we need enough space for ports)
    if (leftPorts > 0 || rightPorts > 0) {
      const maxPortCount = Math.max(leftPorts, rightPorts);
      portBasedWidth = Math.max(30, maxPortCount * 25); // Increased spacing
    }

    // Minimum widths by component type (auto-sizing will expand if needed)
    let minWidth: number;
    switch (type) {
      case ComponentType.RESISTOR:
        minWidth = 60;
        break;
      case ComponentType.CAPACITOR:
        minWidth = 50;
        break;
      case ComponentType.DIODE:
        minWidth = 50;
        break;
      case ComponentType.BUTTON:
        minWidth = 40;
        break;
      case ComponentType.JUNCTION:
        minWidth = 20;
        break;
      case ComponentType.IC:
        minWidth = 80;
        break;
      case ComponentType.MODULE:
        minWidth = 100;
        break;
      case ComponentType.PORT:
        minWidth = 30;
        break;
      default:
        minWidth = 60;
    }

    // Return the maximum of min width and port-based width
    return Math.max(minWidth, portBasedWidth, 40);
  };

  // Helper function to get default height for component types
  const getDefaultComponentHeight = (
    type: ComponentType,
    component: Component
  ): number => {
    // Calculate height based on port count for top/bottom sides
    let portBasedHeight = 0;
    const topPorts = component.ports.filter(
      (p) => getPortSide(p) === "NORTH"
    ).length;
    const bottomPorts = component.ports.filter(
      (p) => getPortSide(p) === "SOUTH"
    ).length;

    // Allocate height based on port count
    if (topPorts > 0 || bottomPorts > 0) {
      const maxPortCount = Math.max(topPorts, bottomPorts);
      portBasedHeight = Math.max(30, maxPortCount * 25);
    }

    // Minimum heights by component type
    let minHeight: number;
    switch (type) {
      case ComponentType.RESISTOR:
        minHeight = 30;
        break;
      case ComponentType.CAPACITOR:
        minHeight = 30;
        break;
      case ComponentType.DIODE:
        minHeight = 30;
        break;
      case ComponentType.BUTTON:
        minHeight = 40;
        break;
      case ComponentType.JUNCTION:
        minHeight = 20;
        break;
      case ComponentType.IC:
        minHeight = 100;
        break;
      case ComponentType.MODULE:
        minHeight = 80;
        break;
      case ComponentType.PORT:
        minHeight = 30;
        break;
      default:
        minHeight = 40;
    }

    // For components with text, ensure minimum height for label visibility
    const textPadding = component.value ? 40 : 30;

    // Return the maximum of min height, port-based height, and text padding
    return Math.max(minHeight, portBasedHeight, textPadding);
  };

  // Use effect to render canvas when layout changes
  useEffect(() => {
    if (layout) {
      renderCanvas();
    }
  }, [layout, renderCanvas]);

  // Display appropriate placeholder if no schematic is provided
  if (!schematic || !currentLevel) {
    return (
      <div className="schematic-viewer">
        <h2>Circuit Schematic</h2>
        <div className="placeholder">
          <p>No schematic data available</p>
        </div>
      </div>
    );
  }

  return (
    <div className="schematic-viewer">
      {/* Navigation breadcrumbs */}
      <div className="schematic-breadcrumbs">
        {currentLevel.parent && (
          <button onClick={handleNavigateUp} className="navigate-up-button">
            ← Back to parent
          </button>
        )}
        <h2>{currentLevel.name}</h2>
        {currentLevel.description && (
          <div className="schematic-description">
            {currentLevel.description}
          </div>
        )}
      </div>

      {/* Display selected component info */}
      {selectedComponent && (
        <div className="component-info">
          {(() => {
            const component = currentLevel.components.find(
              (c) => c.id === selectedComponent
            );
            if (!component) return null;

            return (
              <>
                <h3>Selected: {component.name}</h3>
                <p>Type: {component.type}</p>
                {component.value && <p>Value: {component.value}</p>}
                {component.package && <p>Package: {component.package}</p>}
                {component.hasChildren && (
                  <button
                    onClick={() => onNavigateToChild(component.id)}
                    className="navigate-button"
                  >
                    View Internal Components
                  </button>
                )}
                <button
                  onClick={() => {
                    setSelectedComponent(null);
                    onComponentSelect(null);
                  }}
                  className="deselect-button"
                >
                  Deselect
                </button>
              </>
            );
          })()}
        </div>
      )}

      {/* Render the canvas with interactive elements */}
      <div
        className="canvas-container"
        style={{ width: "100%", height: "100%", overflow: "auto" }}
      >
        <canvas
          ref={canvasRef}
          onClick={handleCanvasClick}
          style={{
            border: "1px solid #ccc",
            cursor: "pointer",
            display: "block",
            margin: "0 auto",
          }}
        />
      </div>

      {/* Display debug info if enabled */}
      {showDebug && (
        <div className="debug-info">
          <h3>Debug Information</h3>
          <div>
            <h4>Current Level: {currentLevel.id}</h4>
            <p>Components: {currentLevel.components.length}</p>
            <p>Connections: {currentLevel.connections.length}</p>
            {currentLevel.children && (
              <p>Child Modules: {currentLevel.children.length}</p>
            )}
          </div>
          {debugInfo && <pre>{JSON.stringify(debugInfo, null, 2)}</pre>}
        </div>
      )}
    </div>
  );
};

export default SchematicViewer;
